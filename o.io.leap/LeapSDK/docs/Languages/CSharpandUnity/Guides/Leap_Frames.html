<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title>Getting Frame Data</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7434 2012-05-11 21:06:27Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { /* line numbers */
  color: grey;
}

.code {
  background-color: #eeeeee
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="getting-frame-data">
<h1 class="title">Getting Frame Data</h1>

<p>The Leap Motion API presents motion tracking data to your application as a series of snapshots called <em>frames</em>. Each frame of tracking data contains the measured positions and other information about each entity detected in that snapshot. This article discusses the details of gettting Frame objects from the Leap Motion controller.</p>
<div class="contents topic" id="topics">
<p class="topic-title first">Topics:</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#getting-frames-by-polling" id="id2">Getting Frames by Polling</a></li>
<li><a class="reference internal" href="#getting-frames-with-callbacks" id="id3">Getting Frames with Callbacks</a></li>
<li><a class="reference internal" href="#getting-data-from-a-frame" id="id4">Getting Data from a Frame</a></li>
<li><a class="reference internal" href="#using-ids-to-track-entities-across-frames" id="id5">Using IDs to track entities across frames</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id1">Overview</a></h1>
<p>Get a Frame object containing tracking data from a connected Controller object. You can get a frame whenever your application is ready to process it using the <cite>frame()</cite> method of the Controller class:</p>
<pre class="code csharp literal-block">
    <span class="k">if</span><span class="p">(</span><span class="n">controller</span><span class="p">.</span><span class="n">IsConnected</span><span class="p">)</span> <span class="c1">//controller is a Controller object
</span>        <span class="p">{</span>
                <span class="n">Frame</span> <span class="n">frame</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">();</span> <span class="c1">//The latest frame
</span>                <span class="n">Frame</span> <span class="n">previous</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="c1">//The previous frame
</span>        <span class="p">}</span>
</pre>
<p>The <cite>frame()</cite> function takes a <cite>history</cite> parameter that indicates how many frames back to retrieve. Typically, the last 60 frames are maintained in the history buffer.</p>
</div>
<div class="section" id="getting-frames-by-polling">
<h1><a class="toc-backref" href="#id2">Getting Frames by Polling</a></h1>
<p>Polling the Controller object for frames is the simplest and often best strategy when your application has a natural frame rate. You just call the Controller <tt class="docutils literal">frame()</tt> function when your application is ready to process a frame of data.</p>
<p>When you use polling, there is a chance that you will get the same frame twice in a row (if the application frame rate exceeds the Leap frame rate) or skip a frame (if the Leap frame rate exceeds the application frame rate). In many cases, missed or duplicated frames are not important. For example, if you are moving an object on the screen in response to hand movement, the movement should still be smooth (assuming the overall frame rate of your application is high enough).</p>
<p>To detect whether you have already processed a frame, save the ID value assigned to the last frame processed and compare it to the current frame:</p>
<pre class="code csharp literal-block">
    <span class="n">Int64</span> <span class="n">lastFrameID</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">processFrame</span><span class="p">(</span> <span class="n">Frame</span> <span class="n">frame</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">Id</span> <span class="p">==</span> <span class="n">lastFrameID</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">//...
</span>        <span class="n">lastFrameID</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Id</span><span class="p">;</span>
    <span class="p">}</span>
</pre>
<p>If your application has skipped frames, you can use the <cite>history</cite> parameter of the <cite>frame()</cite> function to access the skipped frames (as long as the Frame object is still in the history buffer):</p>
<pre class="code csharp literal-block">
    <span class="n">Int64</span> <span class="n">lastProcessedFrameID</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">void</span> <span class="nf">nextFrame</span><span class="p">(</span><span class="n">Controller</span> <span class="n">controller</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Int64</span> <span class="n">currentID</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">().</span><span class="n">Id</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">history</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">history</span> <span class="p">&lt;</span> <span class="n">currentID</span> <span class="p">-</span> <span class="n">lastProcessedFrameID</span><span class="p">;</span> <span class="n">history</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="n">processFrame</span><span class="p">(</span><span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">(</span><span class="n">history</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">lastProcessedFrameID</span> <span class="p">=</span> <span class="n">currentID</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">void</span> <span class="nf">processNextFrame</span><span class="p">(</span><span class="n">Frame</span> <span class="n">frame</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">IsValid</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//...
</span>        <span class="p">}</span>
    <span class="p">}</span>
</pre>
</div>
<div class="section" id="getting-frames-with-callbacks">
<h1><a class="toc-backref" href="#id3">Getting Frames with Callbacks</a></h1>
<p>Alternatively, you can use a Listener object to get frames at the Leap Motion controller's frame rate. The Controller object calls the Listener's <cite>onFrame()</cite> function when a new frame is available. In the onFrame handler, you can call the Controller <tt class="docutils literal">frame()</tt> function to get the Frame object itself.</p>
<p>Using the Listener callbacks is more complex because the callbacks are multi-threaded; each callback is invoked on an independent thread. You must ensure that any data accessed by multiple threads is handled in a thread-safe manner.</p>
<p>The following example defines a minimal Listener subclass that handles new frames of data:</p>
<pre class="code csharp literal-block">
    <span class="k">class</span> <span class="nc">FrameListener</span> <span class="p">:</span> <span class="n">Listener</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">onFrame</span><span class="p">(</span><span class="n">Controller</span> <span class="n">controller</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Frame</span> <span class="n">frame</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">();</span> <span class="c1">//The latest frame
</span>            <span class="n">Frame</span> <span class="n">previous</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="c1">//The previous frame
</span>            <span class="c1">//...
</span>        <span class="p">}</span>
    <span class="p">};</span>
</pre>
<p>As you can see, getting the tracking data through a Listener object is otherwise the same as polling the controller.</p>
<p>Note that it is possible to skip a frame even when using Listener callbacks. If your onFrame callback function takes too long to complete, then the next frame is added to the history, but the onFrame callback is skipped. Less commonly, if the Leap software itself cannot finish processing a frame in time, that frame can be abandoned and not added to the history. This problem can occur when a computer is bogged down with too many other computing tasks.</p>
</div>
<div class="section" id="getting-data-from-a-frame">
<h1><a class="toc-backref" href="#id4">Getting Data from a Frame</a></h1>
<p>The Frame class defines several functions that provide access to the data in the frame. For example, the following code illustrates how to get the basic objects tracked by the Leap Motion system:</p>
<pre class="code csharp literal-block">
        <span class="n">Controller</span> <span class="n">controller</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Controller</span> <span class="p">();</span>
        <span class="c1">// wait until Controller.isConnected() evaluates to true
</span>        <span class="c1">//...
</span>
        <span class="n">Frame</span> <span class="n">frame</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span> <span class="p">();</span>
        <span class="n">HandList</span> <span class="n">hands</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Hands</span><span class="p">;</span>
        <span class="n">PointableList</span> <span class="n">pointables</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Pointables</span><span class="p">;</span>
        <span class="n">FingerList</span> <span class="n">fingers</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Fingers</span><span class="p">;</span>
        <span class="n">ToolList</span> <span class="n">tools</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Tools</span><span class="p">;</span>
</pre>
<p>The objects returned by the Frame object are all read-only. You can safely store them and use them in the future. They are thread-safe. Internally, the objects use the <a class="reference external" href="http://www.boost.org/doc/libs/1_51_0/libs/smart_ptr/shared_ptr.htm#ThreadSafety">C++ Boost library shared pointer class</a>.</p>
</div>
<div class="section" id="using-ids-to-track-entities-across-frames">
<h1><a class="toc-backref" href="#id5">Using IDs to track entities across frames</a></h1>
<p>If you have an ID of an entity from a different frame, you can get the object representing that entity in the current frame. Pass the ID to the Frame function of the appropriate type:</p>
<pre class="code csharp literal-block">
        <span class="n">Hand</span> <span class="n">hand</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Hand</span> <span class="p">(</span><span class="n">handID</span><span class="p">);</span>
        <span class="n">Pointable</span> <span class="n">pointable</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Pointable</span> <span class="p">(</span><span class="n">pointableID</span><span class="p">);</span>
        <span class="n">Finger</span> <span class="n">finger</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Finger</span> <span class="p">(</span><span class="n">fingerID</span><span class="p">);</span>
        <span class="n">Tool</span> <span class="n">tool</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Tool</span> <span class="p">(</span><span class="n">toolID</span><span class="p">);</span>
</pre>
<p>If an object with the same ID cannot be found -- perhaps a hand or finger moved out of the Leap field of view -- then a special, invalid object is returned instead. Invalid objects are instances of the appropriate class, but all their members return 0 values, zero vectors, or other invalid objects. This technique makes it more convenient to chain method calls together. For example, the following code snippet averages finger tip positions over several frames:</p>
<pre class="code csharp literal-block">
        <span class="c1">//Average a finger position for the last 10 frames
</span>        <span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="n">Vector</span> <span class="n">average</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector</span> <span class="p">();</span>
        <span class="n">Finger</span> <span class="n">fingerToAverage</span> <span class="p">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">Fingers</span> <span class="p">[</span><span class="m">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
                <span class="n">Finger</span> <span class="n">fingerFromFrame</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">Frame</span> <span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">Finger</span> <span class="p">(</span><span class="n">fingerToAverage</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">fingerFromFrame</span><span class="p">.</span><span class="n">IsValid</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">average</span> <span class="p">+=</span> <span class="n">fingerFromFrame</span><span class="p">.</span><span class="n">TipPosition</span><span class="p">;</span>
                        <span class="n">count</span><span class="p">++;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">average</span> <span class="p">/=</span> <span class="n">count</span><span class="p">;</span>
</pre>
<p>Without invalid objects, this code would have to check each Frame object before checking the returned Finger objects.</p>
</div>
</div>
</body>
</html>
