<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title>Screen Location</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7434 2012-05-11 21:06:27Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { /* line numbers */
  color: grey;
}

.code {
  background-color: #eeeeee
}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="screen-location">
<h1 class="title">Screen Location</h1>

<p>A user can register the position and orientation of their monitor screens using the Leap Motion Settings dialog. When screen locations are known, you can use the Leap Motion API Screen class to get the physical position and size of that screen in terms of the Leap Motion coordinate system and to find where on the screen a finger or tool is pointing.</p>
<p>Registering the screen location with the Screen Locator utility is not needed for most functions of the Leap Motion system to work properly. Registration is required only when your application uses the Leap::Screen class.</p>
<p><em>Note:</em> The Screen Locator tool and Screen location API are not currently supported on Linux.</p>
<div class="contents topic" id="topics">
<p class="topic-title first">Topics:</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id2">Overview</a><ul>
<li><a class="reference internal" href="#screen-coordinates" id="id3">Screen coordinates</a></li>
<li><a class="reference internal" href="#intersection-and-projection-points" id="id4">Intersection and projection points</a></li>
</ul>
</li>
<li><a class="reference internal" href="#find-the-closest-screen" id="id5">Find the closest screen</a></li>
<li><a class="reference internal" href="#find-the-pixel-coordinates-of-an-intersection-point" id="id6">Find the pixel coordinates of an intersection point</a></li>
<li><a class="reference internal" href="#find-the-leap-motion-coordinates-of-a-projection-point" id="id7">Find the Leap Motion coordinates of a projection point</a></li>
<li><a class="reference internal" href="#set-the-interaction-area-larger-or-smaller" id="id8">Set the interaction area larger or smaller</a></li>
<li><a class="reference internal" href="#find-the-distance-between-the-pointing-finger-or-tool-and-the-screen" id="id9">Find the distance between the pointing finger or tool and the screen</a></li>
</ul>
</div>
<div class="section" id="overview">
<h1><a class="toc-backref" href="#id2">Overview</a></h1>
<p>The Screen class provides the position and orientation of a display screen within the Leap Motion frame of reference. The <tt class="docutils literal"><span class="pre">Screen::intersect()</span></tt> function calculates the position of a point at the intersection between the screen plane and a ray emanating from a finger or tool. Additionally, the <tt class="docutils literal"><span class="pre">Screen::project()</span></tt> function calculates the position of a point projected onto the screen plane.</p>
<p>Before using the Screen class, however, consider that registering the screen location takes a certain amount of effort by the user and that the registered location is only valid until the user moves the monitor or the Leap. Your application's use of the API must be sufficiently valuable that the user feels their effort is worthwhile. We recommend that you make it clear to your users why you need them to register their screen locations and that you provide a quick test for the user to check whether the screen location is still accurate.</p>
<p>For instructions on using the Screen Locator utility, see <a class="reference external" href="Leap_Application.html#screen-location">Screen location</a>.</p>
<div class="section" id="screen-coordinates">
<h2><a class="toc-backref" href="#id3">Screen coordinates</a></h2>
<p>For each known screen, the Screen class provides an origin point and vectors representing the horizontal and vertical extents of the screen. A normal vector is also provided.</p>
<div class="figure">
<img alt="../../../Common/images/Leap_Screen_Space.png" src="../../../Common/images/Leap_Screen_Space.png" />
<p class="caption">The origin and orientation vectors of a located screen.</p>
</div>
<p>The screen origin is placed at the bottom, left-hand corner of the screen. The axis vectors are parallel to the corresponding side of the screen. The length of these vectors represent the length of the screen in millimeters. The normal vector is a unit direction vector perpendicular to the surface of the screen.</p>
</div>
<div class="section" id="intersection-and-projection-points">
<h2><a class="toc-backref" href="#id4">Intersection and projection points</a></h2>
<p>The Screen class provides an <tt class="docutils literal">intersect()</tt> function for calculating the point on the screen where a finger or tool is pointing. The function projects a ray from the Pointable object and determines where that ray intersects the plane of the screen. It returns a valid value as long as the Pointable object is pointing toward the plane in which the screen lies. If the pointer is parallel or pointing away from the screen, then the coordinates contained in the intersection vector are all NaN (not-a-number).</p>
<p>The Screen class also provides a similar <tt class="docutils literal">intersect()</tt> function that accepts a position and direction vector and calculates the screen intersection point of the specified ray, which does not necessarily represent a Pointable object.</p>
<div class="figure">
<img alt="../../../Common/images/Leap_Screen_Intersection.png" src="../../../Common/images/Leap_Screen_Intersection.png" />
<p class="caption">Three pointers with corresponding intersection points.</p>
<div class="legend">
<ul class="simple">
<li><em>Pointer A intersects the screen plane outside the physical screen bounds</em></li>
<li><em>Pointer B intersects the screen directly</em></li>
<li><em>Pointer C does not intersect the screen plane</em></li>
</ul>
</div>
</div>
<p>Additionally, the Screen class provides a <tt class="docutils literal">project()</tt> function for calculating the location on the screen where a point is projected onto its plane. Unlike the <tt class="docutils literal">intersect()</tt> function, the <tt class="docutils literal">project()</tt> function always returns a valid value, as a point can always be projected onto a plane.</p>
<div class="figure">
<img alt="../../../Common/images/Leap_Screen_Projection.png" src="../../../Common/images/Leap_Screen_Projection.png" />
<p class="caption">Two points with corresponding projection points.</p>
<div class="legend">
<ul class="simple">
<li><em>Point A is projected onto the screen directly</em></li>
<li><em>Point B is projected onto the screen plane outside the physical screen bounds</em></li>
</ul>
</div>
</div>
<p>You can request the intersection and projection points in terms of the Leap Motion coordinate system. The coordinates returned form a 3D Vector representing the point in space measured in millimeters from the Leap Motion origin. Alternately, you can request 2D, normalized coordinates, which define the intersection and projection point relative to the bottom, left-hand corner of the screen and within the plane of the screen.</p>
<p>When using normalized coordinates, the origin point is (0, 0, 0) and the opposite, top, right-hand corner is (1, 1, 0). The x and y values for points within the screen plane are always between 0 and 1 and represent the ratio of that point between one side of the screen and another (z values are always zero when using normalized coordinates). For example, the point at the center of the screen has normalized coordinates (0.5, 0.5, 0). Normalized coordinates for intersection and projection points outside the screen border can be less than 0 or greater than 1.</p>
<p>By default, the <tt class="docutils literal">intersect()</tt> and <tt class="docutils literal">project()</tt> functions clamp the normalized coordinates to the range (0..1, 0..1, 0). This means that any intersection or projection points outside the screen border are effectively moved onto the border. You can change the default clamping area by setting the <tt class="docutils literal">clampRatio</tt> parameter when calling the <tt class="docutils literal">intersect()</tt> or <tt class="docutils literal">project()</tt> functions. The default clamp ratio is 1.0. Use a smaller value to decrease the clamping area, and a larger value to increase the area. For example, setting <tt class="docutils literal">clampRatio</tt> to 0.5 limits the interaction area to the center 50% of the screen and clamps all point coordinates between 0.25 and 0.75. Likewise, setting <tt class="docutils literal">clampRatio</tt> to 2.0 doubles the interaction area and clamps point coordinates between -0.5 and 1.5. The resulting interaction area is always centered on the screen's center.</p>
</div>
</div>
<div class="section" id="find-the-closest-screen">
<h1><a class="toc-backref" href="#id5">Find the closest screen</a></h1>
<p>You can get a list of all screens with registered locations from a Controller instance:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
</pre>
<p>Note that the screen list always contains at least one entry, even if the user has never registered the location of a screen. This entry represents the user's default screen.</p>
<p>You can get the closest screen that a ray projected along a finger or tool will intersect from the ScreenList object:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreenHit</span><span class="p">(</span><span class="n">pointable</span><span class="p">);</span>
<span class="p">}</span>
</pre>
<p>Similarly, you can get the closest screen to a point (such as a finger or tool's tip position) from the ScreenList object:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreen</span><span class="p">(</span><span class="n">pointable</span><span class="p">.</span><span class="n">tipPosition</span><span class="p">());</span>
<span class="p">}</span>
</pre>
</div>
<div class="section" id="find-the-pixel-coordinates-of-an-intersection-point">
<h1><a class="toc-backref" href="#id6">Find the pixel coordinates of an intersection point</a></h1>
<p>You can request normalized coordinates from the <tt class="docutils literal">intersect()</tt> function to help calculate the on-screen, pixel coordinates of an intersection point:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreenHit</span><span class="p">(</span><span class="n">pointable</span><span class="p">);</span>

    <span class="n">Vector</span> <span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">pointable</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">xPixel</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">normalizedCoordinates</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">screen</span><span class="p">.</span><span class="n">widthPixels</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">yPixel</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">heightPixels</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">normalizedCoordinates</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">screen</span><span class="p">.</span><span class="n">heightPixels</span><span class="p">());</span>
<span class="p">}</span>
</pre>
</div>
<div class="section" id="find-the-leap-motion-coordinates-of-a-projection-point">
<h1><a class="toc-backref" href="#id7">Find the Leap Motion coordinates of a projection point</a></h1>
<p>You can find the coordinates of a point projected onto the screen plane using the <tt class="docutils literal">project()</tt> function. For example, you may want to project a finger or tool's position onto the closest screen, ignoring its direction:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreen</span><span class="p">(</span><span class="n">pointable</span><span class="p">.</span><span class="n">tipPosition</span><span class="p">());</span>

    <span class="n">Vector</span> <span class="n">screenProjection</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">project</span><span class="p">(</span><span class="n">pointable</span><span class="p">.</span><span class="n">tipPosition</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</div>
<div class="section" id="set-the-interaction-area-larger-or-smaller">
<h1><a class="toc-backref" href="#id8">Set the interaction area larger or smaller</a></h1>
<p>When using normalized coordinates, you make the area in which the user can point larger or smaller by setting the <tt class="docutils literal">clampRatio</tt> parameter when calling the <tt class="docutils literal">intersect()</tt> function. By default, the <tt class="docutils literal">clampRatio</tt> parameter is 1.0, which corresponds to the bounds of the screen. Any points outside these bounds will be clamped to the border when the point coordinates are returned. (Points within the bounds of the interaction area are unaffected by clamping.)</p>
<p>To halve the interaction area, set the <tt class="docutils literal">clampRatio</tt> parameter to 0.5 when you call the <tt class="docutils literal">intersect()</tt> function:</p>
<pre class="code cpp literal-block">
<span class="n">Vector</span> <span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">pointable</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</pre>
<p>To double the area, double the <tt class="docutils literal">clampRatio</tt>:</p>
<pre class="code cpp literal-block">
<span class="n">Vector</span> <span class="n">normalizedCoordinates</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">pointable</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</pre>
</div>
<div class="section" id="find-the-distance-between-the-pointing-finger-or-tool-and-the-screen">
<h1><a class="toc-backref" href="#id9">Find the distance between the pointing finger or tool and the screen</a></h1>
<p>To get the distance between the pointing finger or tool and the screen intersection point, simply subtract the two Vector objects representing these points and get the magnitude of the result. When calling the <tt class="docutils literal">intersect()</tt> function to get the intersection point, set the <tt class="docutils literal">normalized</tt> parameter to false:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreenHit</span><span class="p">(</span><span class="n">pointable</span><span class="p">);</span>

    <span class="n">Vector</span> <span class="n">intersection</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">pointable</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">Vector</span> <span class="n">tipToScreen</span> <span class="o">=</span> <span class="n">intersection</span> <span class="o">-</span> <span class="n">pointable</span><span class="p">.</span><span class="n">tipPosition</span><span class="p">();</span>
    <span class="kt">float</span> <span class="n">pointingDistance</span> <span class="o">=</span> <span class="n">tipToScreen</span><span class="p">.</span><span class="n">magnitude</span><span class="p">();</span>
<span class="p">}</span>
</pre>
<p>To get the shortest distance between the pointing finger and tool and the screen plane, that is, the distance of a perpendicular line segment from the plane to the pointable tip, use the <tt class="docutils literal">distanceToPoint()</tt> function passing in the tip position:</p>
<pre class="code cpp literal-block">
<span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
<span class="n">Frame</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">frame</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pointable</span> <span class="n">pointable</span> <span class="o">=</span> <span class="n">frame</span><span class="p">.</span><span class="n">pointables</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">ScreenList</span> <span class="n">screens</span> <span class="o">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">calibratedScreens</span><span class="p">();</span>
    <span class="n">Screen</span> <span class="n">screen</span> <span class="o">=</span> <span class="n">screens</span><span class="p">.</span><span class="n">closestScreenHit</span><span class="p">(</span><span class="n">pointable</span><span class="p">);</span>

    <span class="kt">float</span> <span class="n">perpendicularDistance</span> <span class="o">=</span> <span class="n">screen</span><span class="p">.</span><span class="n">distanceToPoint</span><span class="p">(</span><span class="n">pointable</span><span class="p">.</span><span class="n">tipPosition</span><span class="p">());</span>
<span class="p">}</span>
</pre>
<hr class="docutils" />
<p>Copyright © 2012-2013 Leap Motion, Inc. All rights reserved.</p>
<p>Leap Motion proprietary and confidential. Not for distribution. Use subject to the terms of the Leap Motion SDK Agreement available at <a class="reference external" href="https://developer.leapmotion.com/sdk_agreement">https://developer.leapmotion.com/sdk_agreement</a>, or another agreement between Leap Motion and you, your company or other organization.</p>
</div>
</div>
</body>
</html>
