/*
  Written by John MacCallum, The Center for New Music and Audio Technologies,
  University of California, Berkeley.  Copyright (c) 2011-12, The Regents of
  the University of California (Regents). 
  Permission to use, copy, modify, distribute, and distribute modified versions
  of this software and its documentation without fee and without a signed
  licensing agreement, is hereby granted, provided that the above copyright
  notice, this paragraph and the following two paragraphs appear in all copies,
  modifications, and distributions.

  IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
  SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
  OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
  BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
  HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
  MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
*/

/** 	\file osc_expr_func.h
	\author John MacCallum

*/
#ifndef __OSC_EXPR_FUNC_H__
#define __OSC_EXPR_FUNC_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <inttypes.h>

#if defined(_WIN32) && defined(__STRICT_ANSI__)
#undef __STRICT_ANSI__
#endif

#include <math.h>
#include "osc_expr_rec.h"
#include "osc_expr_rec.r"
#include "osc_atom_u.h"
#include "osc_atom_array_u.h"


// don't fuck with these!
#define OSC_EXPR_ARG_TYPE_NUMBER 0x1
#define OSC_EXPR_ARG_TYPE_LIST 0x2
#define OSC_EXPR_ARG_TYPE_STRING 0x4
#define OSC_EXPR_ARG_TYPE_ATOM 0x8
#define OSC_EXPR_ARG_TYPE_EXPR 0x10
#define OSC_EXPR_ARG_TYPE_OSCADDRESS 0x20
#define OSC_EXPR_ARG_TYPE_BOOLEAN 0x40
#define OSC_EXPR_ARG_TYPE_FUNCTION 0x80

#define OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS

#define OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR

#define OSC_EXPR_ARG_TYPE_ANYTHING OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS | OSC_EXPR_ARG_TYPE_BOOLEAN

int osc_expr_1arg_dbl(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_2arg_dbl_dbl(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_2arg(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);

int osc_expr_add(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_subtract(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_multiply(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_divide(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_lt(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_lte(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_gt(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_gte(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_eq(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_neq(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_and(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_or(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);
int osc_expr_mod(t_osc_atom_u *f1, t_osc_atom_u *f2, t_osc_atom_u **result);

int osc_expr_assign(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_plus1(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_minus1(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_nth(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_assign_to_index(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_product(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_sum(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_cumsum(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_length(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_mean(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_median(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_reverse(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_sort(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_list(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_nfill(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_range(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_aseq(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_interleave(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_first(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_last(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_rest(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_butlast(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_not(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_dot(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_l2norm(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_min(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_max(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_extrema(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_clip(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_scale(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_mtof(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_ftom(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_sign(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_if(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_strcmp(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_split(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_join(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_bound(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_exists(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_emptybundle(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_getaddresses(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_getmsgcount(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_identity(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_eval_call(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_tokenize(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_compile(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_prog1(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_prog2(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_progn(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_apply(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_map(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_lreduce(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_rreduce(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_quote(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_value(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_lambda(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);

// constants
int osc_expr_pi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_twopi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_halfpi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_quarterpi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_oneoverpi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_twooverpi(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_degtorad(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_radtodeg(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_e(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_lntwo(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_lnten(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_logtwoe(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_logtene(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_sqrttwo(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_sqrthalf(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);

int osc_expr_explicitCast(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);
int osc_expr_explicitCast_float32(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_float64(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_int8(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_int16(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_int32(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_int64(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_uint8(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_uint16(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_uint32(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_uint64(t_osc_atom_u *dest, t_osc_atom_u *src);
int osc_expr_explicitCast_string(t_osc_atom_u *dest, t_osc_atom_u *src);

int osc_expr_typetags(t_osc_expr *f, int argc, t_osc_atom_ar_u **argv, t_osc_atom_ar_u **out);

static struct _osc_expr_rec osc_expr_funcsym[] = {
	// infix
	{"+",
	 "/result = $1 + $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/string/operator", NULL},
	 "Add",
	 osc_expr_2arg,
	 (void *)osc_expr_add},
	//////////////////////////////////////////////////
	{"-",
	 "/result = $1 - $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/string/operator", NULL},
	 "Subtract",
	 osc_expr_2arg,
	 (void *)osc_expr_subtract},
	//////////////////////////////////////////////////
	{"*",
	 "/result = $1 * $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", NULL},
	 "Multiply",
	 osc_expr_2arg,
	 (void *)osc_expr_multiply},
	//////////////////////////////////////////////////
	{"/",
	 "/result = $1 / $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", NULL},
	 "Divide",
	 osc_expr_2arg,
	 (void *)osc_expr_divide},
	//////////////////////////////////////////////////
	{"<",
	 "/result = $1 < $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Less than",
	 osc_expr_2arg,
	 (void *)osc_expr_lt},
	//////////////////////////////////////////////////
	{"<=",
	 "/result = $1 <= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Less than or equal to",
	 osc_expr_2arg,
	 (void *)osc_expr_lte},
	//////////////////////////////////////////////////
	{">",
	 "/result = $1 > $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Greater than",
	 osc_expr_2arg,
	 (void *)osc_expr_gt},
	//////////////////////////////////////////////////
	{">=",
	 "/result = $1 >= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Greater than or equal to",
	 osc_expr_2arg,
	 (void *)osc_expr_gte},
	//////////////////////////////////////////////////
	{"==",
	 "/result = $1 == $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Equal",
	 osc_expr_2arg,
	 (void *)osc_expr_eq},
	//////////////////////////////////////////////////
	{"!=",
	 "/result = $1 != $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", "/string/operator", NULL},
	 "Not equal",
	 osc_expr_2arg,
	 (void *)osc_expr_neq},
	//////////////////////////////////////////////////
	{"&&",
	 "/result = $1 && $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/logical", NULL},
	 "Logical and",
	 osc_expr_2arg,
	 (void *)osc_expr_and},
	//////////////////////////////////////////////////
	{"||",
	 "/result = $1 || $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/logical", NULL},
	 "Logical or",
	 osc_expr_2arg,
	 (void *)osc_expr_or},
	//////////////////////////////////////////////////
	{"%",
	 "/result = $1 % $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", NULL},
	 "Modulo",
	 osc_expr_2arg,
	 (void *)osc_expr_mod},
	//////////////////////////////////////////////////
	{"=",
	 "/result = $1",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/assignment", NULL},
	 "Assignment",
	 osc_expr_assign,
	 NULL},
	//////////////////////////////////////////////////
	{"++",
	 "/result = $1++",
	 1,
	 0,
	 (char *[]){"argument to be incremented"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Increment",
	 osc_expr_plus1,
	 NULL},
	//////////////////////////////////////////////////
	{"--",
	 "/result = $1--",
	 1,
	 0,
	 (char *[]){"argument to be decremented"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Decrement",
	 osc_expr_minus1,
	 NULL},
	//////////////////////////////////////////////////
	{"+=",
	 "/result = $1 += $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Add and assign",
	 osc_expr_2arg,
	 (void *)osc_expr_add},
	//////////////////////////////////////////////////
	{"-=",
	 "/result = $1 -= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Subtract and assign",
	 osc_expr_2arg,
	 (void *)osc_expr_subtract},
	//////////////////////////////////////////////////
	{"*=",
	 "/result = $1 *= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Multiply and assign",
	 osc_expr_2arg,
	 (void *)osc_expr_multiply},
	//////////////////////////////////////////////////
	{"/=",
	 "/result = $1 /= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Divide and assign",
	 osc_expr_2arg,
	 (void *)osc_expr_divide},
	//////////////////////////////////////////////////
	{"%=",
	 "/result = $1 %= $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/arithmetic", "/math/operator/assignment", NULL},
	 "Modulo and assign",
	 osc_expr_2arg,
	 (void *)osc_expr_mod},
	//////////////////////////////////////////////////
	{"??",
	 "/result = $1 ?? $2",
	 2,
	 0,
	 (char *[]){"left operand", "right operand"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/relational", NULL},
	 "Null coalescing operator, returns the left operand if it exists, otherwise it returns the right.",
	 NULL,
	 NULL},
	//////////////////////////////////////////////////
	// functional equivalents of operators
	//////////////////////////////////////////////////
	{"add",
	 "/result = add($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Add",
	 osc_expr_2arg,
	 (void *)osc_expr_add},
	//////////////////////////////////////////////////
	{"sub",
	 "/result = sub($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Subtract",
	 osc_expr_2arg,
	 (void *)osc_expr_subtract},
	//////////////////////////////////////////////////
	{"mul",
	 "/result = mul($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Multiply",
	 osc_expr_2arg,
	 (void *)osc_expr_multiply},
	//////////////////////////////////////////////////
	{"div",
	 "/result = div($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Add",
	 osc_expr_2arg,
	 (void *)osc_expr_add},
	//////////////////////////////////////////////////
	{"lt",
	 "/result = lt($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Less than",
	 osc_expr_2arg,
	 (void *)osc_expr_lt},
	//////////////////////////////////////////////////
	{"le",
	 "/result = lte($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Less than or equal",
	 osc_expr_2arg,
	 (void *)osc_expr_add},
	//////////////////////////////////////////////////
	{"gt",
	 "/result = gt($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Greater than",
	 osc_expr_2arg,
	 (void *)osc_expr_gt},
	//////////////////////////////////////////////////
	{"ge",
	 "/result = ge($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Greater than or equal",
	 osc_expr_2arg,
	 (void *)osc_expr_gte},
	//////////////////////////////////////////////////
	{"eq",
	 "/result = eq($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Equality",
	 osc_expr_2arg,
	 (void *)osc_expr_eq},
	//////////////////////////////////////////////////
	{"ne",
	 "/result = ne($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", "/string", NULL},
	 "Not equal",
	 osc_expr_2arg,
	 (void *)osc_expr_neq},
	//////////////////////////////////////////////////
	{"and",
	 "/result = and($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Logical and",
	 osc_expr_2arg,
	 (void *)osc_expr_and},
	//////////////////////////////////////////////////
	{"or",
	 "/result = or($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Logical or",
	 osc_expr_2arg,
	 (void *)osc_expr_or},
	//////////////////////////////////////////////////
	{"mod",
	 "/result = mod($1, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Modulo",
	 osc_expr_2arg,
	 (void *)osc_expr_mod},
	//////////////////////////////////////////////////
	{"assign",
	 "assign(/result, $2)",
	 2,
	 0,
	 (char *[]){"arg 1", "arg 2"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Assignment",
	 osc_expr_assign,
	 NULL},
	//////////////////////////////////////////////////
	{"plus1",
	 "/result = plus1($1)",
	 1,
	 0,
	 (char *[]){"arg"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Add one and return the result without altering the argument",
	 osc_expr_plus1,
	 NULL},
	//////////////////////////////////////////////////
	{"minus1",
	 "/result = minus1($1)",
	 1,
	 0,
	 (char *[]){"arg"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Subtract one and return the result without altering the argument.",
	 osc_expr_minus1,
	 NULL},
	//////////////////////////////////////////////////
	// most of math.h
	//////////////////////////////////////////////////
	{"abs",
	 "/result = abs($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Absolute value",
	 osc_expr_1arg_dbl,
	 (void *)fabs},
	//////////////////////////////////////////////////
	{"acos",
	 "/result = acos($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Arc cosine",
	 osc_expr_1arg_dbl,
	 (void *)acos},
	//////////////////////////////////////////////////
	{"asin",
	 "/result = asin($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Arc sine",
	 osc_expr_1arg_dbl,
	 (void *)asin},
	//////////////////////////////////////////////////
	{"atan",
	 "/result = atan($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Arc tangent",
	 osc_expr_1arg_dbl,
	 (void *)atan},
	//////////////////////////////////////////////////
	{"atan2",
	 "/result = atan2($1, $2)",
	 2,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Arc tangent of y/x (arg1/arg2)",
	 osc_expr_2arg_dbl_dbl,
	 (void *)atan2},
	//////////////////////////////////////////////////
	{"ceil",
	 "/result = ceil($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Ceiling--round up to the nearest integer",
	 osc_expr_1arg_dbl,
	 (void *)ceil},
	//////////////////////////////////////////////////
	{"cos",
	 "/result = cos($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Cosine",
	 osc_expr_1arg_dbl,
	 (void *)cos},
	//////////////////////////////////////////////////
	{"cosh",
	 "/result = cosh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Hyperbolic cosine",
	 osc_expr_1arg_dbl,
	 (void *)cosh},
	//////////////////////////////////////////////////
	{"exp",
	 "/result = exp($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Exponential function",
	 osc_expr_1arg_dbl,
	 (void *)exp},
	//////////////////////////////////////////////////
	{"floor",
	 "/result = floor($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Round down to the nearest integer",
	 osc_expr_1arg_dbl,
	 (void *)floor},
	//////////////////////////////////////////////////
	{"fmod",
	 "/result = fmod($1, $2)",
	 2,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Floating-point remainder",
	 osc_expr_2arg_dbl_dbl,
	 (void *)fmod},
	//////////////////////////////////////////////////
	{"log",
	 "/result = log($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Natural logarithm",
	 osc_expr_1arg_dbl,
	 (void *)log},
	//////////////////////////////////////////////////
	{"log10",
	 "/result = log10($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Base 10 logarithm",
	 osc_expr_1arg_dbl,
	 (void *)log10},
	//////////////////////////////////////////////////
	{"pow",
	 "/result = pow($1, $2)",
	 2,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Power",
	 osc_expr_2arg_dbl_dbl,
	 (void *)pow},
	//////////////////////////////////////////////////
	{"sin",
	 "/result = sin($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Sine",
	 osc_expr_1arg_dbl,
	 (void *)sin},
	//////////////////////////////////////////////////
	{"sinh",
	 "/result = sinh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Hyperbolic sine",
	 osc_expr_1arg_dbl,
	 (void *)sinh},
	//////////////////////////////////////////////////
	{"sqrt",
	 "/result = sqrt($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Square root",
	 osc_expr_1arg_dbl,
	 (void *)sqrt},
	//////////////////////////////////////////////////
	{"tan",
	 "/result = tan($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Tangent",
	 osc_expr_1arg_dbl,
	 (void *)tan},
	//////////////////////////////////////////////////
	{"tanh",
	 "/result = tanh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Hyperbolic tangent",
	 osc_expr_1arg_dbl,
	 (void *)tanh},
	//////////////////////////////////////////////////
	{"erf",
	 "/result = erf($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Error function (see http://pubs.opengroup.org/onlinepubs/007908799/xsh/erf.html)",
	 osc_expr_1arg_dbl,
	 (void *)erf},
	//////////////////////////////////////////////////
	{"erfc",
	 "/result = erfc($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Complementary error function (see http://pubs.opengroup.org/onlinepubs/007908799/xsh/erf.html)",
	 osc_expr_1arg_dbl,
	 (void *)erfc},
	//////////////////////////////////////////////////
	{"gamma",
	 "/result = gamma($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Log gamma function (same as \"lgamma\")", 
	 osc_expr_1arg_dbl,
	 (void *)lgamma},
	//////////////////////////////////////////////////
	{"hypot",
	 "/result = hypot($1, $2)",
	 2,
	 0,
	 (char *[]){"x", "y"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Euclidean distance",
	 osc_expr_2arg_dbl_dbl,
	 (void *)hypot},
	//////////////////////////////////////////////////
	{"j0",
	 "/result = j0($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "0th Bessel function of the first kind",
	 osc_expr_1arg_dbl,
	 (void *)j0},
	//////////////////////////////////////////////////
	{"j1",
	 "/result = j1($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "1st Bessel function of the first kind",
	 osc_expr_1arg_dbl,
	 (void *)j1},
	//////////////////////////////////////////////////
	{"jn",
	 "/result = jn($1, $2)",
	 2,
	 0,
	 (char *[]){"n", "x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "nth Bessel function of the first kind",
	 osc_expr_2arg_dbl_dbl,
	 (void *)jn},
	//////////////////////////////////////////////////
	{"lgamma",
	 "/result = lgamma($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Log gamma function (same as \"gamma\")",
	 osc_expr_1arg_dbl,
	 (void *)lgamma},
	//////////////////////////////////////////////////
	{"y0",
	 "/result = y0($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "0th Bessel function of the second kind",
	 osc_expr_1arg_dbl,
	 (void *)y0},
	//////////////////////////////////////////////////
	{"y1",
	 "/result = y1($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "1st Bessel function of the second kind",
	 osc_expr_1arg_dbl,
	 (void *)y1},
	//////////////////////////////////////////////////
	{"yn",
	 "/result = yn($1, $2)",
	 2,
	 0,
	 (char *[]){"n", "x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "nth Bessel function of the second kind",
	 osc_expr_2arg_dbl_dbl,
	 (void *)yn},
	//////////////////////////////////////////////////
	{"acosh",
	 "/result = acosh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Inverse hyperbolic cosine",
	 osc_expr_1arg_dbl,
	 (void *)acosh},
	//////////////////////////////////////////////////
	{"asinh",
	 "/result = asinh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Inverse hyperbolic sine",
	 osc_expr_1arg_dbl,
	 (void *)asinh},
	//////////////////////////////////////////////////
	{"atanh",
	 "/result = atanh($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/trigonometric", NULL},
	 "Inverse hyperbolic tangent",
	 osc_expr_1arg_dbl,
	 (void *)atanh},
	//////////////////////////////////////////////////
	{"cbrt",
	 "/result = cbrt($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Cube root",
	 osc_expr_1arg_dbl,
	 (void *)cbrt},
	//////////////////////////////////////////////////
	{"expm1",
	 "/result = expm1($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Exponential function (e^x - 1)",
	 osc_expr_1arg_dbl,
	 (void *)expm1},
	//////////////////////////////////////////////////
	{"ilogb",
	 "/result = ilogb($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Unbiased exponent",
	 osc_expr_1arg_dbl,
	 (void *)ilogb},
	//////////////////////////////////////////////////
	{"logb",
	 "/result = logb($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/power", NULL},
	 "Radix-independent exponent",
	 osc_expr_1arg_dbl,
	 (void *)logb},
	//////////////////////////////////////////////////
	{"nextafter",
	 "/result = nextafter($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "Next representable double-precision floating-point number",
	 osc_expr_2arg_dbl_dbl,
	 (void *)nextafter},
	//////////////////////////////////////////////////
	{"remainder",
	 "/result = remainder($1, $2)",
	 2,
	 0,
	 (char *[]){"x", "y"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Remainder function (r = x - ny where y is non-zero and n is the integral value nearest x/y)",
	 osc_expr_2arg_dbl_dbl,
	 (void *)remainder},
	//////////////////////////////////////////////////
	{"round",
	 "/result = round($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Round to nearest integral value",
	 osc_expr_1arg_dbl,
	 (void *)round},
	//////////////////////////////////////////////////
	{"mod",
	 "/result = mod($1, $2)",
	 2,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Modulo",
	 osc_expr_2arg,
	 (void *)osc_expr_mod},
	//////////////////////////////////////////////////
	{"nth",
	 "/result = nth($1, $2)",
	 2,
	 -1,
	 (char *[]){"argument (list)", "index"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){"additional indexes"},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Get an element of a list (same as [[ ]])",
	 osc_expr_nth,
	 NULL},
	//////////////////////////////////////////////////
	{"assign_to_index",
	 "/result = assign_to_index($1, $2, $3)",
	 3,
	 0,
	 (char *[]){"assignment target", "index(es)", "value(s)"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Assign <arg3> to the indexes <arg2> of the address <arg1>",
	 osc_expr_assign_to_index,
	 NULL},
	//////////////////////////////////////////////////
	{"product",
	 "/result = product($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Product of all the elements of a list",
	 osc_expr_product,
	 NULL},
	//////////////////////////////////////////////////
	{"sum",
	 "/result = sum($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Sum all the elements of a list",
	 osc_expr_sum,
	 NULL},
	//////////////////////////////////////////////////
	{"cumsum",
	 "/result = cumsum($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Cumulative sum",
	 osc_expr_cumsum,
	 NULL},
	//////////////////////////////////////////////////
	{"length",
	 "/result = length($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Get the length of a list",
	 osc_expr_length,
	 NULL},
	//////////////////////////////////////////////////
	{"avg",
	 "/result = avg($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "The average of a list (same as mean)",
	 osc_expr_mean,
	 NULL},
	//////////////////////////////////////////////////
	{"mean",
	 "/result = mean($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "The average of a list (same as avg)",
	 osc_expr_mean,
	 NULL},
	//////////////////////////////////////////////////
	{"median",
	 "/result = median($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Median of a list of values",
	 osc_expr_median,
	 NULL},
	//////////////////////////////////////////////////
	{"reverse",
	 "/result = reverse($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Reverse the order of the elements of a list",
	 osc_expr_reverse,
	 NULL},
	//////////////////////////////////////////////////
	{"rev",
	 "/result = rev($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Reverse the order of the elements of a list",
	 osc_expr_reverse,
	 NULL},
	//////////////////////////////////////////////////
	{"sort",
	 "/result = sort($1)",
	 1,
	 -1,
	 (char *[]){"List to be sorted"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"Additional lists to be sorted"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/vector", NULL},
	 "Sort the elements of a list",
	 osc_expr_sort,
	 NULL},
	//////////////////////////////////////////////////
	{"list",
	 "/result = list($1, $2)",
	 0,
	 -1,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"elements to be gathered into a list"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR_STR},
	 (char *[]){"/vector", NULL},
	 "Assemble the arguments into a list.",
	 osc_expr_list,
	 NULL},
	//////////////////////////////////////////////////
	{"nfill",
	 "/result = nfill($1, $2)",
	 1,
	 1,
	 (char *[]){"number of items"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"value (default = 0)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS | OSC_EXPR_ARG_TYPE_STRING},
	 (char *[]){"/vector", NULL},
	 "Make a list of <arg1> copies of <arg2>.  <arg2> is optional and defaults to 0",
	 osc_expr_nfill,
	 NULL},
	//////////////////////////////////////////////////
	{"aseq",
	 "/result = aseq($1, $2, $3)",
	 2,
	 1,
	 (char *[]){"min", "max"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"step (default = 1)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/vector", NULL},
	 "Arithmetic progression from <arg1> to <arg2> in <arg3> steps.  <arg3> is optional and defaults to 1",
	 osc_expr_aseq,
	 NULL},
	//////////////////////////////////////////////////
	/*
	  {"gseq",
	  "/result = ",
	  -1,
	  0,
	  (char *[]){NULL},
	  (char *[]){NULL},
	  (char *[]){"/vector", NULL},
	  "Geometric sequence from <arg1> to <arg2> in <arg3> steps.  <arg3> is optional and defaults to 1",
	  osc_expr_gseq,
	  NULL},
	*/
	//////////////////////////////////////////////////
	{"interleave",
	 "/result = interleave($1, $2)",
	 2,
	 -1,
	 (char *[]){"list 1", "list 2"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"additional lists (list, OSC address)"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/vector", NULL},
	 "Interleave two or more lists",
	 osc_expr_interleave,
	 NULL},
	//////////////////////////////////////////////////
	{"first",
	 "/result = first($1)",
	 1,
	 0,
	 (char *[]){"list"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Get the first element of a list.",
	 osc_expr_first,
	 NULL},
	//////////////////////////////////////////////////
	{"last",
	 "/result = last($1)",
	 1,
	 0,
	 (char *[]){"list"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Get the last element of a list.",
	 osc_expr_last,
	 NULL},
	//////////////////////////////////////////////////
	{"rest",
	 "/result = rest($1)",
	 1,
	 0,
	 (char *[]){"list"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Get everything after the first element of a list.",
	 osc_expr_rest,
	 NULL},
	//////////////////////////////////////////////////
	{"butlast",
	 "/result = butlast($1)",
	 1,
	 0,
	 (char *[]){"list"},
	 (int []){OSC_EXPR_ARG_TYPE_LIST | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/vector", NULL},
	 "Get everything but the last element of a list.",
	 osc_expr_butlast,
	 NULL},
	//////////////////////////////////////////////////
	{"!",
	 "/result = !$1",
	 1,
	 0,
	 (char *[]){"argument"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/operator/logical", NULL},
	 "Logical not",
	 osc_expr_not,
	 NULL},
	//////////////////////////////////////////////////
	{"dot",
	 "/result = dot($1, $2)",
	 2,
	 0,
	 (char *[]){"list 1", "list 2"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Dot product of arg1 and arg2",
	 osc_expr_dot,
	 NULL},
	//////////////////////////////////////////////////
	{"l2norm",
	 "/result = l2norm($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Norm of the argument",
	 osc_expr_l2norm,
	 NULL},
	//////////////////////////////////////////////////
	{"min",
	 "/result = min($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Minimum value of the arguments",
	 osc_expr_min,
	 NULL},
	//////////////////////////////////////////////////
	{"max",
	 "/result = max($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Maximum value of the arguments",
	 osc_expr_max,
	 NULL},
	//////////////////////////////////////////////////
	{"range",
	 "/result = range($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Range of the arguments",
	 osc_expr_extrema,
	 NULL},
	//////////////////////////////////////////////////
	{"extrema",
	 "/result = extrema($1)",
	 1,
	 0,
	 (char *[]){"argument (list)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/statistics", NULL},
	 "Min and max of the arguments",
	 osc_expr_extrema,
	 NULL},
	//////////////////////////////////////////////////
	{"clip",
	 "/result = clip($1, $2, $3)",
	 3,
	 0,
	 (char *[]){"value(s) to be clipped", "min", "max"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/conversion", NULL},
	 "Clip the data between arg2 and arg3",
	 osc_expr_clip,
	 NULL},
	//////////////////////////////////////////////////
	{"scale",
	 "/result = scale($1, $2, $3, $4, $5)",
	 5,
	 0,
	 (char *[]){"value(s) to be scaled", "input min", "input max", "output min", "output max"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/conversion", NULL},
	 "Scale arg1 from arg1:arg2 to arg3:arg4",
	 osc_expr_scale,
	 NULL},
	//////////////////////////////////////////////////
	{"mtof",
	 "/result = mtof($1)",
	 1,
	 1,
	 (char *[]){"midi note number"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){"base (default = 440)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/math/conversion", NULL},
	 "MIDI note number to frequency.  Optional arg2 sets base.",
	 osc_expr_mtof,
	 NULL},
	//////////////////////////////////////////////////
	{"ftom",
	 "/result = ftom($1)",
	 1,
	 1,
	 (char *[]){"frequency in Hz."},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){"base (default = 440)"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/math/conversion", NULL},
	 "Frequency to MIDI. Optional arg2 sets base.",
	 osc_expr_ftom,
	 NULL},
	//////////////////////////////////////////////////
	{"sign",
	 "/result = sign($1)",
	 1,
	 0,
	 (char *[]){"x"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/arithmetic", NULL},
	 "Sign function--returns -1 if <arg1> < 0, 0 if <arg1> == 0, and 1 if <arg1> > 1",
	 osc_expr_sign,
	 NULL},
	//////////////////////////////////////////////////
	{"if",
	 "/result = if($1, $2, $3)",
	 2,
	 1,
	 (char *[]){"test", "then"},
	 (int []){OSC_EXPR_ARG_TYPE_BOOLEAN | OSC_EXPR_ARG_TYPE_NUMBER, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"else"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/conditional", NULL},
	 "Conditionally execute <arg2> or optional <arg3> based on the result of <arg1>",
	 osc_expr_if,
	 NULL},
	//////////////////////////////////////////////////
	{"strcmp",
	 "/result = strcmp($1, $2)",
	 2,
	 1,
	 (char *[]){"String 1", "String 2"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"Number of characters to compare"},
	 (int []){OSC_EXPR_ARG_TYPE_NUMBER | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/string", NULL},
	 "Compare two strings.",
	 osc_expr_strcmp,
	 NULL},
	//////////////////////////////////////////////////
	{"split",
	 "/result = split(\"/\", $1)",
	 2,
	 0,
	 (char *[]){"Separator", "String"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/string", NULL},
	 "Split a string at a separator.",
	 osc_expr_split,
	 NULL},
	//////////////////////////////////////////////////
	{"join",
	 "/result = join(\"/\", $1)",
	 2,
	 -1,
	 (char *[]){"Separator", "String"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"More strings"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){"/string", NULL},
	 "Join multiple strings with a separator.",
	 osc_expr_join,
	 NULL},
	//////////////////////////////////////////////////
	{"bound",
	 "/result = bound($1)",
	 1,
	 0,
	 (char *[]){"OSC address"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/predicate", NULL},
	 "True if the address exists and has data bound to it, false otherwise.",
	 osc_expr_bound,
	 NULL},
	//////////////////////////////////////////////////
	{"exists",
	 "/result = exists($1)",
	 1,
	 0,
	 (char *[]){"OSC address"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/predicate", NULL},
	 "True if the address exists (regardless of whether it has data bound to it.",
	 osc_expr_exists,
	 NULL},
	//////////////////////////////////////////////////
	{"emptybundle",
	 "/result = emptybundle()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/predicate", NULL},
	 "True if the bundle is empty, false otherwise.",
	 osc_expr_emptybundle,
	 NULL},
	//////////////////////////////////////////////////
	{"getaddresses",
	 "/result = getaddresses()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Returns a list of all addresses in the bundle.",
	 osc_expr_getaddresses,
	 NULL},
	//////////////////////////////////////////////////
	{"getmsgcount",
	 "/result = getmsgcount()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Returns the number of messages in the bundle.",
	 osc_expr_getmsgcount,
	 NULL},
	//////////////////////////////////////////////////
	{"identity",
	 "/result = identity($1)",
	 1,
	 0,
	 (char *[]){"argument"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/specialfunction", NULL},
	 "Returns its argument",
	 osc_expr_identity,
	 NULL},
	//////////////////////////////////////////////////
	{"eval",
	 "/result = eval($1)",
	 1,
	 0,
	 (char *[]){"OSC address or expression"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Evaluate an expression bound to an OSC address.",
	 osc_expr_eval_call,
	 NULL},
	//////////////////////////////////////////////////
	{"tokenize",
	 "/result = tokenize($1)",
	 1,
	 0,
	 (char *[]){"OSC address or expression"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Tokenize an expression",
	 osc_expr_tokenize,
	 NULL},
	//////////////////////////////////////////////////
	/*
	  {"compile",
	  "/result = compile($1, $2)",
	  2,
	  0,
	  (char *[]){NULL},
	  (int []){},
	  (char *[]){NULL},
	  (int []){},
	  (char *[]){"/core", NULL},
	  "Compile a function <arg2> and bind it to an OSC address <arg1>",
	  osc_expr_compile,
	  NULL},
	*/
	//////////////////////////////////////////////////
	{"prog1",
	 "/result = prog1($1)",
	 1,
	 -1,
	 (char *[]){"expression to be evaluated"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"additional expressions"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/core", NULL},
	 "Execute a sequence of expressions and return the first one.",
	 osc_expr_prog1,
	 NULL},
	//////////////////////////////////////////////////
	{"prog2",
	 "/result = prog2($1)",
	 1,
	 -1,
	 (char *[]){"expression to be evaluated"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"additional expressions"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/core", NULL},
	 "Execute a sequence of expressions and return the second one.",
	 osc_expr_prog2,
	 NULL},
	//////////////////////////////////////////////////
	{"progn",
	 "/result = progn($1)",
	 1,
	 -1,
	 (char *[]){"expression to be evaluated"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"additional expressions"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/core", NULL},
	 "Execute a sequence of expressions and return the last one.",
	 osc_expr_progn,
	 NULL},
	//////////////////////////////////////////////////
	{"apply",
	 "/result = apply($1, $2)",
	 2,
	 -1,
	 (char *[]){"Function or function name", "Argument"},
	 (int []){OSC_EXPR_ARG_TYPE_FUNCTION | OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"Additional argument(s)"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/core", NULL},
	 "Apply a function to arguments.",
	 osc_expr_apply,
	 NULL},
	//////////////////////////////////////////////////
	{"map",
	 "/result = map($1, $2)",
	 2,
	 -1,
	 (char *[]){"Function or function name", "OSC address or list"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS | OSC_EXPR_ARG_TYPE_FUNCTION, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"Additional lists"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/vector", NULL},
	 "Map arguments onto a function and return the result as a list.",
	 osc_expr_map,
	 NULL},
	//////////////////////////////////////////////////
	{"lreduce",
	 "/result = reduce($1, $2)",
	 2,
	 1,
	 (char *[]){"Function or function name", "OSC address or list to reduce"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS | OSC_EXPR_ARG_TYPE_FUNCTION, OSC_EXPR_ARG_TYPE_ANYTHING, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"Start value"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/vector", NULL},
	 "Combine the elements of a list using a left-associative binary operation.",
	 osc_expr_lreduce,
	 NULL},
	//////////////////////////////////////////////////
	{"rreduce",
	 "/result = reduce($1, $2)",
	 2,
	 1,
	 (char *[]){"Function or function name", "OSC address or list to reduce"},
	 (int []){OSC_EXPR_ARG_TYPE_STRING | OSC_EXPR_ARG_TYPE_OSCADDRESS | OSC_EXPR_ARG_TYPE_FUNCTION, OSC_EXPR_ARG_TYPE_ANYTHING, OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"Start value"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){"/vector", NULL},
	 "Combine the elements of a list using a right-associative binary operation.",
	 osc_expr_rreduce,
	 NULL},
	//////////////////////////////////////////////////
	{"quote",
	 "/result = quote($1)",
	 1,
	 0,
	 (char *[]){"argument"},
	 (int []){OSC_EXPR_ARG_TYPE_ANYTHING},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Prevent the evaluation of <arg1>.",
	 osc_expr_quote,
	 NULL},
	//////////////////////////////////////////////////
	{"value",
	 "/result = value($1)",
	 1,
	 0,
	 (char *[]){"argument"},
	 (int []){OSC_EXPR_ARG_TYPE_OSCADDRESS},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Return the value associated with the argument.",
	 osc_expr_value,
	 NULL},
	//////////////////////////////////////////////////
	{"lambda",
	 "",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Anonymous function",
	 osc_expr_lambda,
	 NULL},
	//////////////////////////////////////////////////
	{"pi",
	 "/result = pi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "pi: 3.14159...",
	 osc_expr_pi,
	 NULL},
	//////////////////////////////////////////////////
	{"twopi",
	 "/result = twopi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "2 * pi: 6.28318...",
	 osc_expr_twopi,
	 NULL},
	//////////////////////////////////////////////////
	{"halfpi",
	 "/result = halfpi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "pi / 2: 1.57079...",
	 osc_expr_halfpi,
	 NULL},
	//////////////////////////////////////////////////
	{"quarterpi",
	 "/result = quarterpi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "pi / 4: 0.78539...",
	 osc_expr_quarterpi,
	 NULL},
	//////////////////////////////////////////////////
	{"oneoverpi",
	 "/result = oneoverpi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "1 / pi: 0.31830...",
	 osc_expr_oneoverpi,
	 NULL},
	//////////////////////////////////////////////////
	{"twooverpi",
	 "/result = twooverpi()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "2 / pi: 0.63661...",
	 osc_expr_twooverpi,
	 NULL},
	//////////////////////////////////////////////////
	{"degtorad",
	 "/result = degtorad()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "Multiply by angle to get radians (0.017453...)",
	 osc_expr_degtorad,
	 NULL},
	//////////////////////////////////////////////////
	{"radtodeg",
	 "/result = radtodeg()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "Multiply by angle in radians to get degrees (57.29578...)",
	 osc_expr_radtodeg,
	 NULL},
	//////////////////////////////////////////////////
	{"e",
	 "/result = e()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "e: 2.718282...",
	 osc_expr_e,
	 NULL},
	//////////////////////////////////////////////////
	{"lntwo",
	 "/result = lntwo()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "ln 2: 0.69314...",
	 osc_expr_lntwo,
	 NULL},
	//////////////////////////////////////////////////
	{"lnten",
	 "/result = lnten()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "ln 10: 2.30258...",
	 osc_expr_lnten,
	 NULL},
	//////////////////////////////////////////////////
	{"logtwoe",
	 "/result = logtwoe()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "log(2 * e): 1.44269...",
	 osc_expr_logtwoe,
	 NULL},
	//////////////////////////////////////////////////
	{"logtene",
	 "/result = logtene()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "log(10 * e): 0.43420...",
	 osc_expr_logtene,
	 NULL},
	//////////////////////////////////////////////////
	{"sqrttwo",
	 "/result = sqrttwo()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "sqrt(2): 1.41421...",
	 osc_expr_sqrttwo,
	 NULL},
	//////////////////////////////////////////////////
	{"sqrthalf",
	 "/result = sqrthalf()",
	 0,
	 0,
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/math/constant", NULL},
	 "sqrt(0.5): 0.70710...",
	 osc_expr_sqrthalf,
	 NULL},
	//////////////////////////////////////////////////
	{"float32",
	 "/result = float32($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to float32",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_float32},
	//////////////////////////////////////////////////
	{"float64",
	 "/result = float64($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to float64",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_float64},
	//////////////////////////////////////////////////
	/*
	{"float",
	 "/result = float($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to float (float32)",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_float32},
	//////////////////////////////////////////////////
	{"double",
	 "/result = double($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to double (float64)",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_float64},
	*/
	//////////////////////////////////////////////////
	{"int8",
	 "/result = int8($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to int8",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_int8},
	//////////////////////////////////////////////////
	{"char",
	 "/result = char($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to char (int8)",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_int8},
	//////////////////////////////////////////////////
	{"int16",
	 "/result = int16($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to int16",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_int16},
	//////////////////////////////////////////////////
	{"int32",
	 "/result = int32($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to int32",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_int32},
	//////////////////////////////////////////////////
	{"int64",
	 "/result = int64($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to int64",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_int64},
	//////////////////////////////////////////////////
	{"uint8",
	 "/result = uint8($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to uint8",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_uint8},
	//////////////////////////////////////////////////
	{"uint16",
	 "/result = uint16($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to uint16",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_uint16},
	//////////////////////////////////////////////////
	{"uint32",
	 "/result = uint32($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to uint32",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_uint32},
	//////////////////////////////////////////////////
	{"uint64",
	 "/result = uint64($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to uint64",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_uint64},
	//////////////////////////////////////////////////
	{"string",
	 "/result = string($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Cast to string",
	 osc_expr_explicitCast,
	 (void *)osc_expr_explicitCast_string},
	//////////////////////////////////////////////////
	{"typetags",
	 "/result = typetags($1)",
	 1,
	 0,
	 (char *[]){"argument to be converted"},
	 (int []){OSC_EXPR_ARG_TYPE_NUM_LIST_ADDR},
	 (char *[]){NULL},
	 (int []){},
	 (char *[]){"/core", NULL},
	 "Get the typetags associated with <arg1> as a list of int8s",
	 osc_expr_typetags,
	 NULL}

};

#ifdef _cplusplus
}
#endif

#endif // __OSC_EXPR_FUNC_H__
