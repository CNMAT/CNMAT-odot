/*

Written by Matt Wright, The Center for New Music and Audio Technologies,
University of California, Berkeley.  Copyright (c) 1996,97,98,99,2000,01,02,03,04,05
The Regents of the University of California (Regents).  

Permission to use, copy, modify, distribute, and distribute modified versions
of this software and its documentation without fee and without a signed
licensing agreement, is hereby granted, provided that the above copyright
notice, this paragraph and the following two paragraphs appear in all copies,
modifications, and distributions.

IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

*/

#ifdef O_SLIPSERIAL_ENCODE
#define OMAX_DOC_NAME "o.slipserial.encode"
#define OMAX_DOC_SHORT_DESC "SLIP encodes an OSC packet and outputs a stream of bytes."
#define OMAX_DOC_LONG_DESC "SLIP encodes an OSC packet and outputs a stream of bytes suitable for use with Max's serial object."
#define OMAX_DOC_INLETS_DESC (char *[]){"FullPacket"}
#define OMAX_DOC_OUTLETS_DESC (char *[]){"Byte stream"}
#define OMAX_DOC_SEEALSO  (char *[]){"o.slipserial.decode"}
#elif defined(O_SLIPSERIAL_DECODE)
#define OMAX_DOC_NAME "o.slipserial.decode"
#define OMAX_DOC_SHORT_DESC "Decodes a SLIP stream and outputs an OSC packet."
#define OMAX_DOC_LONG_DESC "Decodes a SLIP stream and converts it into an OSC packet."
#define OMAX_DOC_INLETS_DESC (char *[]){"Bytes (int or list)"}
#define OMAX_DOC_OUTLETS_DESC (char *[]){"FullPacket"}
#define OMAX_DOC_SEEALSO  (char *[]){"o.slipserial.encode"}
#endif

#include "odot_version.h"
#ifdef OMAX_PD_VERSION
#include "m_pd.h"
#else
#include "ext.h"
#include "ext_obex.h"
#include "ext_obex_util.h"
#include "ext_critical.h"
#ifdef O_SLIPSERIAL_ENCODE
#include "omax_dict.h"
#endif
#endif
#include "osc.h"
#include "osc_mem.h"
#include "osc_serial.h"
#include "omax_util.h"
#include "omax_doc.h"
#include "o.h"

t_class *oslipserial_class;

t_symbol *ps_gimme, *ps_OSCTimeTag, *ps_FullPacket, *ps_OSCBlob;

#define MAXSLIPBUF 2048

typedef struct oslipserial {
	t_object ob;
	void *outlet;  
  
	char slipibuf[MAXSLIPBUF]; // buffer used to write the new packet
	char slipobuf[MAXSLIPBUF]; // buffer used to output a completed packet
	int icount;
	short istate; // initialize to 0
	t_atom  *out;
	t_critical lock;

} t_oslipserial;

void *oslipserial_new(long arg);
void oslipserial_assist(t_oslipserial *x, void *b, long m, long a, char *s);
void oslipserial_debug (t_oslipserial *x);
void oslipserial_errorreporting(t_oslipserial *x, int yesno);

void oslipserial_send(t_oslipserial *x);

void oslipserial_bang(t_oslipserial *x);
void oslipserial_readtypestrings(t_oslipserial *x, int yesno);
void oslipserial_writetypestrings(t_oslipserial *x, int yesno);
void oslipserial_printcontents(t_oslipserial *x);

void oslipserial_accumulateMessage(t_oslipserial *x, char *messageName, short argc, t_atom *argv);
int oslipserial_stringSubstitution(char *target, char *format, short *argcp, t_atom **argvp);
void oslipserial_sendBuffer(t_oslipserial *x);
void oslipserial_sendData(t_oslipserial *x, short size, char *data);

#ifdef __MWERKS__
#define DONT_HAVE_STRING_LIBRARY
/* KLUDGE!!! 
If we're on metrowerks we must be compiling for PPC which is big-endian, so since I don't know
where to link in the real ntohl() I'll define this evil macro: */
#define ntohl(x) (x)
#endif

#ifdef DONT_HAVE_STRING_LIBRARY
void strcpy(char *s1, char *s2);
#endif

// SLIP codes
#define END             0300    // indicates end of packet 
#define ESC             0333    // indicates byte stuffing 
#define ESC_END         0334    // ESC ESC_END means END data byte 
#define ESC_ESC         0335    // ESC ESC_ESC means ESC data byte
void oslipencode_FullPacket(t_oslipserial *x, long size, unsigned char *source);

void oslipencode_FullPacket(t_oslipserial *x, long size, unsigned char *source) {
  
  if(((size%4)==0) && size<MAXSLIPBUF &&  size>4 && (source[0]=='/' || source[0]=='#')) {
    
    int i=0;
    unsigned char c;
    
    x->out[i++].a_w.w_long  = END;
    for(i=0;i<size && i<MAXSLIPBUF-3;++i) {
      switch(c=*source++)
	{
	case END:
	  x->out[i++].a_w.w_long = ESC;
	  x->out[i].a_w.w_long = ESC_END;
	  break;
	  
	case ESC:
	  x->out[i++].a_w.w_long = ESC;
	  x->out[i].a_w.w_long = ESC_ESC;
	  break;
	  
	default:
	  x->out[i].a_w.w_long = c;
	  
	}
    }
    
    x->out[i++].a_w.w_long  = END;
    
#ifdef DEBUGOUTPUT
    {
      // full packet process		
      char stringbuf[4096];
      int j=0;
      int p;
      for(p=0;p<i && p<4095;++p)
	{
	  unsigned char c = x->out[p].a_w.w_long;
	  if(c=='/' || c=='#' || c==' ' ||  (c>='a' && c<='z')  || (c>='A' && c<='Z') || (c<='9' && c>='0') )
	    stringbuf[j++] = c;
	  else
	    stringbuf[j++] = '*';
	}
      stringbuf[j++] = '\0';
      object_post((t_object *)x, "packet %d %s", i, stringbuf);
    }
#endif
    
    outlet_list(x->O_outlet2,0L,(short)i,x->out);
    
  }
  else 
    object_post((t_object *)x, "slipOSC: bad fullpacket");
  
}
  
int slipdecode(t_oslipserial *x, unsigned char c)
{

  int t;

  
  switch(x->istate)
    {
    case 0: // waiting for packet to start
      x->istate = 1;
      if(c==END)
	break;
      
    case 1: // packet has started
      switch(c )
	{
	case END:
	  if((x->icount > 0)) // it was the END byte
	    { 
#ifdef DEBUGOUTPUT					
	      // full packet process		
	      char stringbuf[4096];
	      int j=0;
	      int i;
	      for(p=0;i<x->icount && i<4095;++i)
		{
		  char c = x->slipibuf[i];
		  if(c=='/' || c=='#' || (c>='a' && c<='z')  || (c>='A' && c<='Z') || (c<='9' && c>='0') )
		    stringbuf[j++] = c;
		  else
		    stringbuf[j++] = '*';
		}
	      stringbuf[j++] = '\0';
	      object_post((t_object *)x, "slipOSC: packet %d %s", x->icount, stringbuf);
#endif
	      // ParseOSCPacket(x, x->slipibuf, x->icount, true);
	      t = x->icount;
	      x->icount = 0;
	      x->istate = 0;
	      
	      if((t % 4) == 0) { 
		oslipserial_sendData(x, t, x->slipibuf);
		return 0;
	      } // else bad packet not a multiple four length...

	    }
	  x->istate = 0;
	  break;
	case ESC:
	  x->istate =2;
	  break;
	  
	  // otherwise, just stick it in the packet	 buffer	
	default:
	  if(x->icount<MAXSLIPBUF)
	    {	x->slipibuf[(x->icount)++] = c; }
	  else
	    x->istate = 3;
	  break;
	}
      break;
    case 2: // process escapes
      switch( c )
	{
	case ESC_END:
	  if(x->icount<MAXSLIPBUF)
	    {	
	      x->slipibuf[(x->icount)++] = END;
	      x->istate = 1;
	    }
	  else
	    x->istate = 3;
	  
	  break;
	case ESC_ESC:
	  if(x->icount<MAXSLIPBUF)
	    {	
	      x->slipibuf[(x->icount)++] = ESC;
	      x->istate = 1;
	    }
	  else
	    x->istate = 3;
	  break;
	default:
	  object_post((t_object *)x, "slipOSC: ESC not followed by ESC_END or ESC_ESC.");
	  x->istate = 3;
	}
      break;
    case 3:   // error state: hunt for END character (this should probably be a hunt for a non escaped END character..
      if( c == END)
	{
	  x->icount = 0;
	  x->istate = 0;
	}
      break;
      
    }

return 1;
 

}

void slipbyte(t_oslipserial *x, long n)
{
  if((x->m_inletNumber==1) && n<256)
{
	  critical_enter(x->lock);
}
	if(slipdecode(x, n))
		critical_exit(x->lock);
}

void sliplist(t_oslipserial *x, struct symbol *s, int argc, struct atom *argv)
{
  int i;
  if(x->m_inletNumber!=1)
    return;
  for(i=0; i<argc; ++i) {
    if(argv[i].a_type != A_LONG) {	
      object_post((t_object *)x, "slipOSC: list did not contain only integers; dropping");
      return;
    }
  }
	  critical_enter(x->lock);
 
  for(i=0;i<argc;++i) {
    int  e = argv[i].a_w.w_long;	
    if(e<256)
      if(!slipdecode(x,e))
	  {
	  	  critical_enter(x->lock);
	  }
  }
  critical_exit(x->lock);
 
}

void myobject_free(t_oslipserial *x);
void myobject_free(t_oslipserial *x)
{
  freeobject(x->m_proxy);
  critical_free(x->lock);
}

int main (void) {
  
  version_post_copyright();
  
  oslipserial_class = class_new("slipOSC", (method) oslipserial_new,(method) myobject_free,(short)sizeof(oslipserial),0L,A_DEFLONG,0);
  
#ifdef SANITY_CHECK
  object_post((t_object *)x, "*** sizeof(int4byte) = %ld", (long) sizeof(int4byte));
  object_post((t_object *)x, "*** sizeof(long) = %ld", (long) sizeof(long));
#endif

  class_addmethod(oslipserial_class, (method)oslipserial_assist, "assist", A_CANT,0);
  class_addmethod(oslipserial_class, (method)version, "version", 0);
  class_addmethod(oslipserial_class, (method)oslipserial_debug, "debug", 0);
  class_addmethod(oslipserial_class, (method)oslipserial_errorreporting, "errorreporting", A_LONG, 0);
  
  class_addmethod(oslipserial_class, (method)slipbyte, "int", A_LONG, 0);
  class_addmethod(oslipserial_class, (method)sliplist, "list", A_GIMME, 0);
  
  class_addmethod(oslipserial_class, (method)oslipserial_printcontents, "printcontents", 0);
  class_addmethod(oslipserial_class, (method)slipencodeFullPacket, "FullPacket", A_LONG, A_LONG, 0);
  
  finder_addclass("Devices","slipOSC");
  // rescopy('STR#',3009);
  ps_OSCTimeTag = gensym("OSCTimeTag");
  ps_FullPacket = gensym("FullPacket");
    class_register(CLASS_BOX, oslipserial_class);
    return 0;
}

void *oslipserial_new(long arg) {
  oslipserial *x;
  char *buf;
  
  x = (oslipserial *) object_alloc(oslipserial_class);
  if(!x){
	  return NULL;
  }
  x->m_proxy = proxy_new(x,1L,&x->m_inletNumber);
  
  /* Create the outlets in right to left order */
  x->O_outlet3 = outlet_new(x, "OSCTimeTag");
  x->O_outlet2 = outlet_new(x, 0L);
  x->O_outlet1 = outlet_new(x, 0L);
  
  
  x->O_debug = false;
  
  x->icount = 0;
  x->istate = 0;
  x->out = 		(t_atom *) getbytes(MAXSLIPBUF * sizeof(t_atom));
  
  if (x->out == 0) {
    object_post((t_object *)x, "slipOSC: not enough memory for capacity %ld!",MAXSLIPBUF);
    
    return 0;
  }
  
  {
    int i;
    for (i = 0; i<MAXSLIPBUF; ++i) {
      x->out[i].a_type = A_LONG;
    }
  }

  critical_new(&(x->lock));
  
  return (x);
}

void oslipserial_assist(t_oslipserial *x, void *b, long m, long a, char *dst) {
  if (m == ASSIST_INLET) {
    if (a == 0) {
      strcpy(dst, "Max msgs; OSC packets");
    } else {
      object_error((t_object *)x, "oslipserial_assist: unrecognized inlet number %ld", a);
    }
  } else if (m == ASSIST_OUTLET) {
    if (a == 0) {
      strcpy(dst, "OSC packets; bang after msgs in OSC packet");
    } else if (a == 1) {
      strcpy(dst, "OSC msgs decoded from OSC packet");
    } else if (a == 2) {
      strcpy(dst, "Time tag (list of two ints) from OSC packet");
    } else {
      object_error((t_object *)x, "oslipserial_assist: unrecognized outlet number %ld", a);
    }
  } else {
    object_error((t_object *)x, "Unexpected msg %ld in oslipserial_assist", m);
  }
}

void oslipserial_sendData(t_oslipserial *x, short size, char *data) {
  
  t_atom arguments[2];
  char fullpacket[MAXSLIPBUF];
  
  if (x->O_debug) {
    object_post((t_object *)x, "slipOSC: Sending buffer (%ld bytes)", (long) size);
  }
  
  memcpy(fullpacket, data, size);

  // safe to release lock now...
  critical_exit(x->lock);
  
  atom_setlong(&arguments[0], (long) size);
  atom_setlong(&arguments[1], (long) fullpacket);
  outlet_anything(x->O_outlet1, ps_FullPacket, 2, arguments);
  
}

void oslipserial_doc(t_oslipserial *x)
{
	omax_doc_outletDoc(x->outlet);
}
#ifdef O_SLIPSERIAL_ENCODE
OMAX_DICT_DICTIONARY(t_oslipserial, x, oslipserial_fullPacket);
#endif

#define MAX_ARGS_TO_oslipserial_MSG 1024

#define PRINTABLE(c) ((char) (c>= 0x20 && c <= 0x7e ? c : 'û'))
#define isprint(c) ((c) >= 0x20 && (c) <= 0x7e)

void oslipserial_printcontents (t_oslipserial *x) {
  char *m, buf[100], *p;
  int n, i;
  
  m = x->slipibuf;
  n = x->icount;
  
  object_post((t_object *)x, "oslipserial_printcontents: buffer %p, size %ld", m, (long) n);
  
  if (n % 4 != 0) {
    object_post((t_object *)x, "Hey, the size isn't a multiple of 4!");
  } else {
    for (i = 0; i < n; i += 4) {
      p = buf;
      
      p += sprintf(p, "  %x", m[i]);
      if (isprint(m[i])) {
	p += sprintf(p, "  (%c)", m[i]);
      } else {
	p += sprintf(p, "  ()");
      }
      
      p += sprintf(p, "  %x", m[i+1]);
      if (isprint(m[i+1])) {
	p += sprintf(p, "  (%c)", m[i+1]);
      } else {
	p += sprintf(p, "  ()");
      }
      
      p += sprintf(p, "  %x", m[i+2]);
      if (isprint(m[i+2])) {
	p += sprintf(p, "  (%c)", m[i+2]);
      } else {
	p += sprintf(p, "  ()");
      }
      
      p += sprintf(p, "  %x", m[i+3]);
      if (isprint(m[i+3])) {
	p += sprintf(p, "  (%c)", m[i+3]);
      } else {
	p += sprintf(p, "  ()");
      }
      
      *p = '\0';
      object_post((t_object *)x, buf);	    		 
    }
  }
}

#ifdef PRECOMPUTE_SIZES
/* In the old days, we used to have to compute the size of our messages
   by hand to see if there was room in the buffer. */

int oslipserial_messageSize(char *messageName, short argc, t_atom *argv) {
  int result;
  int i;
  
  /* First, we need space for the messageName */
  result = oslipserial_effectiveStringLength(messageName);	
 slipOSC.c:266: warning: return type of 'main' is not 'int'
    
    /* Now account for the arguments */
    for (i = 0; i < argc; i++) {
      switch (argv[i].a_type) {
      case A_LONG:
	result += sizeof(long);
	break;
	
      case A_FLOAT:
	result += sizeof(float);
	break;
	
      case A_SYM:
	result += oslipserial_effectiveStringLength(argv[i].a_w.w_sym->s_name);
	break;
	
      default:
	object_error((t_object *)x, "slipOSC: unrecognized argument type");
	break;
      }
    }
  
  return result;
}
#endif


/*******************************************************************
 Stuff having to do with parsing incoming OSC packets into Max data
 *******************************************************************/

void ParseOSCPacket(t_oslipserial *x, char *buf, long n, int topLevel);
char *DataAfterAlignedString(char *string, char *boundary); 
int IsNiceString(char *string, char *boundary);
#ifdef DONT_HAVE_STRING_LIBRARY
int strncmp(char *s1, char *s2, int n);
#endif

char *htm_error_string;	// Used for error messages

#define SMALLEST_POSITIVE_FLOAT 0.000001f
#define MAXARGS 500

#define STRING_ALIGN_PAD 4

char *DataAfterAlignedString(char *string, char *boundary) 
{
  /* The argument is a block of data beginning with a string.  The
     string has (presumably) been padded with extra null characters
     so that the overall length is a multiple of STRING_ALIGN_PAD
     bytes.  Return a pointer to the next byte after the null
     byte(s).  The boundary argument points to the character after
     the last valid character in the buffer---if the string hasn't
     ended by there, something's wrong.
     
     If the data looks wrong, return 0, and set htm_error_string */
  
  int i;
  
  if ((boundary - string) %4 != 0) {
    ouchstring("slipOSC: Internal error: DataAfterAlignedString: bad boundary\n");
    return 0;
  }
  
  for (i = 0; string[i] != '\0'; i++) {
    if (string + i >= boundary) {
      htm_error_string = "DataAfterAlignedString: Unreasonably long string";
      return 0;
    }
  }
  
  /* Now string[i] is the first null character */
  i++;
  
  for (; (i % STRING_ALIGN_PAD) != 0; i++) {
    if (string + i >= boundary) {
      htm_error_string = "DataAfterAlignedString: Unreasonably long string";
      return 0;
    }
    if (string[i] != '\0') {
      htm_error_string = "DataAfterAlignedString: Incorrectly padded string.";
      return 0;
    }
  }
  
  return string+i;
}

int IsNiceString(char *string, char *boundary)  {
  /* Arguments same as DataAfterAlignedString().  Is the given "string"
     really a string?  I.e., is it a sequence of isprint() characters
     terminated with 1-4 null characters to align on a 4-byte boundary? */
  
  int i;
  
  if ((boundary - string) %4 != 0) {
    ouchstring("slipOSC: Internal error: IsNiceString: bad boundary\n");
    return 0;
  }
  
  for (i = 0; string[i] != '\0'; i++) {
    if (!isprint(string[i])) return FALSE;
    if (string + i >= boundary) return FALSE;
  }
  
  /* If we made it this far, it's a null-terminated sequence of printing characters 
     in the given boundary.  Now we just make sure it's null padded... */
  
  /* Now string[i] is the first null character */
  i++;
  for (; (i % STRING_ALIGN_PAD) != 0; i++) {
    if (string[i] != '\0') return FALSE;
  }
  
  return TRUE;
}

#ifdef DONT_HAVE_STRING_LIBRARY
int strncmp(char *s1, char *s2, int n) {
  while (n > 0) {
    if (*s1 != *s2) return *s2 - *s1;
    if (*s1 == 0) return 0;
    s1++; s2++; n--;
  }
}
#endif
