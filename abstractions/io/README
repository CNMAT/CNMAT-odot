o.io

INTRODUCTION

o.io builds on CNMAT's "o." programming environment providing a framework for harmonizing input and output for a wide variety of devices. Initial development was  focussed  on musical instrument controllers. Now o.io supports streams of information from game controllers, MIDI devices, biometric sensors, lighting controllers, touch and pen input and wireless sources and sinks of such as x-OSC and Bluetooth LE.

USE
We continue to build up the library of supported devices. There is a good chance we have already provided support for a device you are interested in. Our convention is to name the module supporting a device with product name "widget" as o.io.widget. Some of these devices are interpretations of the pointer device built into your computer. Try o.io.manual,  for example. This is the name for a simulation of a musical keyboard. Another basic one is o.io.cursor.

OSC AS LINGUA FRANCA
The key idea in o.io is to transcode information  into a popular, well characterized encoding: OSC. We also try to represent all the capabilities of a device in a single, self describing OSC bundle so you don't have to look these capabilities up in a manual. Exploring how to use an   device with o.io is usually as simple as monitoring the output stream from the o.io device module.

DEVELOPMENT OF NEW O.IO MODULES

Basic transcoding is rather straightforward because you can build on the various helper components we provide such as o.io.midi and o.io.hid. We invite you to embrace some of the design patterns and aesthetic concerns we have developed over the years to go beyond basic transcoding to creating the richer OSC representations that afford easier gesture analysis, processing and mapping. These are described in more detail in a white paper. Below we simply summarize some of the helpful design patterns.

DESIGN PATTERNS

*Transcoding
Represent values as named values in OSC. At this stage these names may be generic and related to the protocol, e.g. MIDI or HID controller numbers.

*Interpretation
Name, normalize and structure parameters that connect to the physical interaction with the device. 

*State Caching
Many devices use the "Send on Change" approach. We have found it much easier to develop applications that use o.io modules  if we go to the trouble of representing the entire state of a device in a single bundle and send the whole bundle out when a change occurs. 

*Simulation
We have found it helpful to develop simulations of physical devices. This process helps verify the design of the o.io device module, provides a proxy for a broken,  lost or absent physical device and a basis on which to design new devices.
